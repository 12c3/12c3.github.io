<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring boot（二）mybatis篇]]></title>
    <url>%2Fhtml%2F51b216f9.html</url>
    <content type="text"><![CDATA[说明上文介绍Spring boot基本信息和简单示例，接下来我们进一步完善框架，这里选择目前主流的mybatis来做ORM框架管理数据库。选择mybatis的优势：1.上手简单熟悉SQL语句即可 2.低耦合便于优化（SQL语句都统一处理，方便后期优化调整） 示例打开上文的示例demo代码，因为yml配置文件更具有层次性，出于代码可阅读性，我们这里把配置文件application.properties更换为application.yml类型，需要注意的是参数值前面需要加空格。 1.添加maven模块依赖，项目选择最常用的mysql数据库，在pom文件里面添加如下代码：123456789101112131415161718192021&lt;dependencies&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 代码格式化工具 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; PS：lombok依赖主要用于生成Get和Set方法以及基本构造函数，优点是减少代码量提升可阅读性。 2.添加完maven依赖之后，在配置文件application.yml里增加相应配置。123456789101112spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/demo?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8 username: user password: passwordserver: port: 10008 #mybatis配置，可在主程序入口添加@MapperScan("com.example.demo.mapper.*")代替配置mybatis: mapper-locations: classpath:mapping/*Mapper.xml type-aliases-package: com.example.demo.entity url 数据库连接，格式为jdbc:mysql://ip:port/name?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8 username 数据库用户名称 password 数据库用户密码 driver-class-name 驱动名称，这里选择mysql驱动即可 3.创建mybatis相关包和文件在com.example.demo目录下创建entity和mapper目录，然后分别创建UserEntity.java、UserMapper.java、UserMapper.xml文件。 UserEntity.java：映射数据表结构，字段与数据库表字段对应。 123456789101112131415161718192021222324252627282930313233package com.example.demo.entity;import lombok.Data;import java.util.Date;@Datapublic class UserEntity &#123; /** * 主键ID */ private Integer id; /** * 用户名称 */ private String name; /** * 手机号码 */ private String mobile; /** * 逻辑删除标识 0：未删除 1：已删除 */ private Integer deleteFlag; /** * 创建时间 */ private Date createTime;&#125; 数据库建表语句：12345678CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键ID', `name` varchar(20) DEFAULT NULL COMMENT '用户名称', `mobile` varchar(20) DEFAULT NULL COMMENT '手机号码', `createTime` datetime DEFAULT NULL COMMENT '创建时间', `deleteFlag` tinyint(1) DEFAULT NULL COMMENT '逻辑删除标识0：未删除1：已删除', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci; UserMapper.java：@Mapper注解标记对应数据操作映射，一个方法对应一个操作，如：下图中的queryList()方法就是一个查询操作。123456789101112131415package com.example.demo.mapper;import com.example.demo.entity.UserEntity;import org.apache.ibatis.annotations.Mapper;import java.util.List;@Mapperpublic interface UserMapper&#123; /** * 查询用户列表 * @return */ List&lt;UserEntity&gt; queryList();&#125; UserMapper.xml：对应UserMapper.java文件，id和UserMapper.java文件的方法名称对应，映射实际执行SQL语句。12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.example.demo.mapper.UserMapper"&gt; &lt;!--查询user表所有数据--&gt; &lt;select id="queryList" resultType="com.example.demo.entity.UserEntity"&gt; select * from user; &lt;/select&gt;&lt;/mapper&gt; PS：程序打包时默认资源文件在resources文件夹下，而我们的UserMapper.xml文件在src/main/java目录下，所以需要在pom.xml文件声明资源文件打包进去，否则无法加载。当然也可以直接在resources目录下增加xml文件，这样就不需要声明。1234567891011121314151617181920212223242526&lt;build&gt; &lt;!--资源文件打包--&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;includes&gt; &lt;include&gt;**/*.*&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!--maven打包插件--&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 4.在TestController中添加测试代码：运行成功之后，我们可以在浏览器上测试下接口返回结果 如图:TestController.java：接口示例代码12345678910111213141516171819202122package com.example.demo.controller;import com.example.demo.mapper.UserMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController//声明这个类为返回rest风格的web控制器@RequestMapping(value = "test")//声明接口父类路径，用于归类区分接口类型public class TestController &#123; //注入dao操作 @Autowired private UserMapper userMapper; @RequestMapping(value = "getName")//声明实际接口路径 public Object getName(String name)&#123; //String name 请求参数，不传则返回null //Object 返回数据类型，这里测试统一为Object，后续可以指定响应对象 return userMapper.queryList();//返回结果 &#125;&#125; 结语一个最基本的Spring boot后端API框架就算搭建完成，接下来我们只需要根据业务添加相应的业务代码即可，你们说是不是觉得很简单呢。附：示例demo源码]]></content>
      <categories>
        <category>Spring boot</category>
      </categories>
      <tags>
        <tag>Spring boot</tag>
        <tag>Spring boot入门</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring boot（一）入门篇]]></title>
    <url>%2Fhtml%2Fc0321393.html</url>
    <content type="text"><![CDATA[说明什么是Spring boot？这些网上各种说明都有，这里只说下个人自己的理解：严格来说Spring boot不算是一个框架，它只能说是一款集成主流常用框架的新型开发模式。Spring boot的核心理念就是约定大于配置，所以说它最大的魅力就在于减少开发人员不必要的配置，从而达到开箱即用的快速开发效果。 快速开始Spring boot官网地址，找到Quick start点击下面的Spring Initializr进入demo下载页面选择maven工程java语言最后选择自己想要的Spring boot版本（默认是最新稳定版）最后点击创建下载即可下载完成之后解压文件得到项目工程，这是一个最基本的Spring boot工程，这里用IDEA打开项目（maven工程直接选中pom.xml即可）当然也可以选择eclipse，这里就不细说工具区别了。项目结构说明：除开src文件夹和pom.xml文件，其他都是些maven或者Git的说明文件，可以直接删除并不影响项目代码 src/main/java 代码主体主程序入口 src/main/resources 资源文件与配置文件 src/main/test 测试主体程序入口，测试代码可以删除 打开代码之后你会发现工程非常简单，如图总共才三个文件：1.DemoApplication文件，是整个工程的启动配置类，由@SpringBootApplication注解标明使用，此注解的作用就是开启整个项目的配置文件，由@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan三个注解组成，依次作用为初始化加载配置、开启自动配置、开启扫描配置。也可以单独使用这三个注解，两者效果是一样的，用@SpringBootApplication只是为了简化操作。2.application.properties文件，这是整个工程的配置文件，它有自己最基本的默认配置（上面说的魅力所在），比如说端口号默认8080等，由于是基本demo工程没有其他配置，所以整个文件为空采用默认的基本配置。3.pom.xml文件，maven的作用是依赖管理，而这个文件则是整个maven工程的依赖和配置声明，由此可见其重要性。运行主程序main方法，至此一个基础java项目搭建完成。 简单示例在搭建理解完整个工程结构之后，我们接下来实现一个简单的查询接口功能1.首先添加web模块依赖，在pom文件里面添加如下代码：123456789101112131415161718&lt;dependencies&gt; &lt;!-- 核心模块（默认切必须） --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 测试模块（默认可去掉） --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- web模块 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.添加完maven依赖之后，这里简单说明下SPring boot建议代码结构示意图1234567891011121314com +- example +- myproject +- Application.java | +- domain | +- Customer.java | +- CustomerRepository.java | +- service | +- CustomerService.java | +- controller | +- CustomerController.java Application 主程序入口-默认放在项目最上层 domain 实体类和数据传输对象 service 业务实现代码 controller 接口控制器 3.编写简单查询接口在com.example.demo目录下创建controller目录，然后创建TestController.java文件1234567891011121314package com.example.demo.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(value = "test")public class TestController &#123; @RequestMapping(value = "getName") public Object getName(String name)&#123; return "我的名字是："+name; &#125;&#125; 4.运行示例程序 如图：运行成功之后，我们可以在浏览器上测试下接口返回结果 如图:5.示例接口代码说明12345678910111213141516package com.example.demo.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController//声明这个类为返回rest风格的web控制器@RequestMapping(value = "test")//声明接口父类路径，用于归类区分接口类型public class TestController &#123; @RequestMapping(value = "getName")//声明实际接口路径 public Object getName(String name)&#123; //String name 请求参数，不传则返回null //Object 返回数据类型，这里测试统一为Object，后续可以指定响应对象 return "我的名字是："+name;//返回结果 &#125;&#125; 6.简单配置示例在application.properties里添加如下代码，重新运行程序，请求端口改为10008测试，否则会提示拒绝连接12#指定请求端口server.port=10008 结语经过一个简单的示例，大家都应该体验到Spring boot的魅力所在。但是有得必有失，当我们习惯这种模式时，同时也失去了一定学习和深入了解Spring Mvc机制的机会。附：示例demo源码]]></content>
      <categories>
        <category>Spring boot</category>
      </categories>
      <tags>
        <tag>Spring boot</tag>
        <tag>Spring boot入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客迁移]]></title>
    <url>%2Fhtml%2Fb97fcdf6.html</url>
    <content type="text"><![CDATA[前言Hexo是一个简洁、高效的静态博客框架，而Hexo框架使用是基于当前电脑的安装和配置，本文讲述的是如果我们有一天更换电脑或者重装系统时应该如何优雅的迁移博客系统。 说明这里默认您已成功使用Hexo和GitHub发布博客，所以使用GitHub进行存储备份博客系统文件，当然有其他更好的存储方式也可以替换。具体思路：利用GitHub的存储库特性，使用GitHub存储Hexo博客系统文件，这样我们不管在那台电脑上都可以随时更新发布博客。 操作创建一个新GitHub存储库，然后clone到本地进行操作，当然也可以直接使用博客发布的静态库生成新的分支。1$ git clone https://github.com/12c3/MyBlog.git 添加Hexo博客文件到GitHub仓库，这里要注意一点，需要忽略一些指定文件。这里需要说明一下，因为博主改过一些源生的文件所以这里是连带主题和插件这些一起备份，以求达到无缝迁移备份效果，也就是下载下来就可以直接使用不做任何改动。因为我们这里做的是备份博客源文件，所以像动态生成的文件这些都是需要忽略的。如根目录下.deploy_git、public生成的静态html文件，以及db.json、.gitignore文件，处理完根目录文件之后，我们还需要来到主题下面删除不必要的文件，需要注意的是，对于git配置文件一定要删除，不然会造成一些文件提交不上去的问题。 修改前Hexo博客文件列表： 修改后Hexo博客文件列表： 修改前主题文件列表： 修改后主题文件列表： 把修改后的所有文件上传到我们新建的GitHub存储库，由于文件比较多所以提交的时候需要稍微等待一会。123$ git add .$ git commit -m 'MyBlog init'$ git push origin master 为避免我们提交不必要的文件，添加GitHub过滤规则文件.gitignore具体规则内容如下: 123456789#静态文件过滤public/#推送文件过滤.deploy*/#数据日志过滤db.json*.log.DS_StoreThumbs.db 上传到GitHub存储库之后，我们的迁移备份基本就完成了，在新环境使用的时只需在安装好Hexo之后把备份clone下来即可运行，注意不需要hexo init,直接在clone的文件下运行即可。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo迁移备份</tag>
      </tags>
  </entry>
</search>
